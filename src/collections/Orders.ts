import type { CollectionConfig } from "payload";

import { isSuperAdmin } from "@/lib/access";
import type { Tenant, Product } from "@/payload-types";
import { sendOrderNotification } from '@/lib/notifications/send-push';

export const Orders: CollectionConfig = {
  slug: "orders",
  hooks: {
    beforeChange: [
      async ({ data, operation }) => {
        // Auto-generate orderNumber on create
        if (operation === 'create' && !data.orderNumber) {
          const timestamp = Date.now().toString().slice(-8);
          const random = Math.random().toString(36).substring(2, 6).toUpperCase();
          data.orderNumber = `ORD-${timestamp}-${random}`;
        }
        return data;
      }
    ],
    afterChange: [
      async ({ doc, operation, req, previousDoc }) => {
        // Send push notification when order is created
        if (operation === 'create') {
          try {
            // Get product details
            const product = await req.payload.findByID({
              collection: 'products',
              id: typeof doc.product === 'string' ? doc.product : doc.product.id,
              depth: 1,
            });

            // Get tenant ID from product
            const tenantId = typeof product.tenant === 'string' ? product.tenant : (product.tenant as Tenant)?.id;
            const productName = (product as Product).name || 'Unknown Product';

            if (tenantId) {
              // Notify tenant of new order
              sendOrderNotification(
                tenantId,
                doc.orderNumber || doc.id,
                productName
              ).catch((error) => {
                req.payload.logger.error(`Failed to send order notification: ${error}`);
              });
            }
          } catch (error) {
            req.payload.logger.error(`Failed to get product details for notification: ${error}`);
          }
        }

        // TEMPORARILY DISABLED: Create sale record when order is created (after payment verification)
        // TODO: Re-enable after fixing "Category, Location" validation error
        if (false && operation === 'create') {
          try {
            // Get product details
            const product = await req.payload.findByID({
              collection: 'products',
              id: typeof doc.product === 'string' ? doc.product : doc.product.id,
              depth: 1,
            });

            // Get user details
            const user = await req.payload.findByID({
              collection: 'users',
              id: typeof doc.user === 'string' ? doc.user : doc.user.id,
              depth: 0,
            });

            // Calculate amounts
            const totalAmount = doc.totalAmount || 0;
            const platformFee = 0; // No platform fee
            const netAmount = totalAmount; // Tenant receives full amount

            // Get tenant ID from product
            const tenantId = typeof product.tenant === 'string' ? product.tenant : (product.tenant as any)?.id;

            // Skip if tenant ID is not available
            if (!tenantId) {
              req.payload.logger.warn(`⚠️ Cannot create sale record: No tenant ID for order ${doc.id}`);
              return;
            }

            // Create sale record
            await req.payload.create({
              collection: 'sales',
              data: {
                saleNumber: '', // Will be auto-generated by hook
                tenant: tenantId,
                product: typeof doc.product === 'string' ? doc.product : doc.product.id,
                order: doc.id,
                customer: typeof doc.user === 'string' ? doc.user : doc.user.id,
                customerName: user.username || user.email,
                customerEmail: user.email,
                quantity: doc.products?.[0]?.quantity || 1,
                pricePerUnit: doc.products?.[0]?.priceAtPurchase || product.price,
                totalAmount,
                platformFee,
                netAmount,
                status: doc.status,
                paymentMethod: doc.paymentMethod === 'bank_transfer' ? 'bank_transfer' : 'mobile_money',
                transactionId: doc.transactionId,
              },
            });

            req.payload.logger.info(`✅ Sale record created for order ${doc.orderNumber}`);
          } catch (error) {
            req.payload.logger.error(`❌ Failed to create sale record for order ${doc.id}:`);
            req.payload.logger.error(error);
            // Don't throw - order creation should still succeed even if sale creation fails
          }
        }

        // Update sale status when order status changes
        if (operation === 'update' && previousDoc.status !== doc.status) {
          try {
            // Find the sale record for this order
            const salesData = await req.payload.find({
              collection: 'sales',
              where: {
                order: {
                  equals: doc.id,
                },
              },
              limit: 1,
            });

            if (salesData.docs[0]) {
              const updateData: any = {
                status: doc.status,
              };

              // Update timestamps based on status
              if (doc.status === 'shipped' && doc.shippedAt) {
                updateData.shippedAt = doc.shippedAt;
              }
              if (doc.status === 'delivered' && doc.deliveredAt) {
                updateData.deliveredAt = doc.deliveredAt;
              }
              if (doc.status === 'completed' && doc.confirmedAt) {
                updateData.completedAt = doc.confirmedAt;
              }

              // Update the sale record
              await req.payload.update({
                collection: 'sales',
                id: salesData.docs[0].id,
                data: updateData,
              });

              req.payload.logger.info(`✅ Sale status updated for order ${doc.orderNumber}: ${doc.status}`);
            }
          } catch (error) {
            req.payload.logger.error(`❌ Failed to update sale record for order ${doc.id}:`, error);
          }
        }
      },
    ],
  },
  access: {
    read: async ({ req }) => {
      // Super admin can see all orders
      if (isSuperAdmin(req.user)) return true;

      // Check if user has a tenant
      if (!req.user?.tenants || req.user.tenants.length === 0) {
        return false;
      }

      // Get tenant information
      const tenantRel = req.user.tenants[0];
      if (!tenantRel) return false;
      
      const tenantId = typeof tenantRel.tenant === 'string' ? tenantRel.tenant : tenantRel.tenant?.id;

      if (!tenantId) return false;

      // All tenants can see their orders (verified or not)

      // Return query to only show orders for products belonging to this tenant
      // We need to fetch products first, then filter orders
      const products = await req.payload.find({
        collection: 'products',
        where: {
          tenant: {
            equals: tenantId,
          },
        },
        limit: 1000, // Adjust if needed
        depth: 0,
      });

      const productIds = products.docs.map(p => p.id);

      if (productIds.length === 0) {
        return false; // No products, no orders
      }

      // Return query to filter orders by product IDs
      return {
        product: {
          in: productIds,
        },
      };
    },
    create: ({ req }) => isSuperAdmin(req.user), // Only system/admin can create orders
    update: async ({ req }) => {
      // Super admin can update all orders
      if (isSuperAdmin(req.user)) return true;

      // Tenants can update their own orders (e.g., mark as shipped/delivered)
      if (!req.user?.tenants || req.user.tenants.length === 0) {
        return false;
      }

      const tenantRel = req.user.tenants[0];
      if (!tenantRel) return false;
      
      const tenantId = typeof tenantRel.tenant === 'string' ? tenantRel.tenant : tenantRel.tenant?.id;

      if (!tenantId) return false;

      // All tenants can update their orders (verified or not)

      // Get tenant's products
      const products = await req.payload.find({
        collection: 'products',
        where: { tenant: { equals: tenantId } },
        limit: 1000,
        depth: 0,
      });

      const productIds = products.docs.map(p => p.id);

      // Allow update only for orders of tenant's products
      return {
        product: {
          in: productIds,
        },
      };
    },
    delete: ({ req }) => isSuperAdmin(req.user), // Only super admin can delete orders
  },
  admin: {
    useAsTitle: "name",
    defaultColumns: ['orderNumber', 'user', 'status', 'totalAmount', 'createdAt'],
  },
  fields: [
    {
      name: "orderNumber",
      type: "text",
      required: true,
      unique: true,
      admin: {
        description: "Unique order reference number",
        readOnly: true,
      }
    },
    {
      name: "name",
      type: "text",
      required: true,
    },
    {
      name: "user",
      type: "relationship",
      relationTo: "users",
      required: true,
      hasMany: false,
      admin: {
        description: "Customer who placed the order"
      }
    },
    {
      name: "products",
      type: "array",
      required: true,
      fields: [
        {
          name: "product",
          type: "relationship",
          relationTo: "products",
          required: true,
        },
        {
          name: "quantity",
          type: "number",
          required: true,
          min: 1,
          defaultValue: 1,
        },
        {
          name: "priceAtPurchase",
          type: "number",
          required: true,
          admin: {
            description: "Price of the product at time of purchase"
          }
        }
      ]
    },
    {
      name: "product",
      type: "relationship",
      relationTo: "products",
      required: true,
      hasMany: false,
      admin: {
        description: "Main product (for backwards compatibility)"
      }
    },
    {
      name: "totalAmount",
      type: "number",
      required: true,
      admin: {
        description: "Total order amount in RWF"
      }
    },
    {
      name: "transaction",
      type: "relationship",
      relationTo: "transactions",
      hasMany: false,
      maxDepth: 0, // Prevent deep population to avoid circular reference with Transactions
      admin: {
        description: "Related verified transaction"
      }
    },
    {
      name: "deliveryType",
      type: "select",
      required: true,
      defaultValue: "direct",
      options: [
        { label: "Direct Payment (Pickup)", value: "direct" },
        { label: "Delivery", value: "delivery" },
      ],
      admin: {
        description: "Delivery type inherited from transaction. Direct orders allow immediate pickup confirmation after payment verification.",
      }
    },
    {
      name: "shippingAddress",
      type: "group",
      fields: [
        {
          name: "line1",
          type: "text",
          admin: {
            description: "Address line 1"
          }
        },
        {
          name: "city",
          type: "text",
          admin: {
            description: "City"
          }
        },
        {
          name: "country",
          type: "text",
          admin: {
            description: "Country"
          }
        },
      ],
      admin: {
        description: "Customer shipping address (inherited from transaction for delivery orders)",
        condition: (data) => data.deliveryType === 'delivery',
      }
    },
    {
      name: "status",
      type: "select",
      defaultValue: "pending",
      required: true,
      options: [
        { label: "Pending - Payment Verified", value: "pending" },
        { label: "Shipped - Item Sent", value: "shipped" },
        { label: "Delivered - Awaiting Confirmation", value: "delivered" },
        { label: "Completed - Customer Confirmed", value: "completed" },
        { label: "Refunded", value: "refunded" },
        { label: "Cancelled", value: "cancelled" },
      ],
      admin: {
        description: "Order fulfillment status. Direct orders: pending → completed (after pickup confirmation). Delivery orders: pending → shipped → delivered → completed (after delivery confirmation).",
        components: {
          Cell: '@/components/admin/OrderStatusCell#OrderStatusCell',
        },
      }
    },
    {
      name: "confirmedAt",
      type: "date",
      admin: {
        description: "Date when customer confirmed receipt of item",
        condition: (data) => data.status === 'completed'
      }
    },
    {
      name: "shippedAt",
      type: "date",
      admin: {
        description: "Date when item was shipped",
        condition: (data) => ['shipped', 'delivered', 'completed'].includes(data.status)
      }
    },
    {
      name: "deliveredAt",
      type: "date",
      admin: {
        description: "Date when item was delivered",
        condition: (data) => ['delivered', 'completed'].includes(data.status)
      }
    },
    {
      name: "received",
      type: "checkbox",
      defaultValue: false,
      admin: {
        description: "Customer confirmed receipt of order",
        readOnly: true,
        position: "sidebar",
      }
    },
    {
      name: "transactionId",
      type: "text",
      required: true,
      admin: {
        description: "Transaction ID from mobile money or bank transfer"
      }
    },
    {
      name: "paymentMethod",
      type: "select",
      required: true,
      options: [
        { label: "Mobile Money", value: "mobile_money" },
        { label: "Bank Transfer", value: "bank_transfer" },
      ],
      admin: {
        description: "Payment method used for this transaction"
      }
    },
    {
      name: "bankName",
      type: "text",
      admin: {
        description: "Bank name or mobile money provider",
        condition: (data) => data.paymentMethod === 'bank_transfer' || data.paymentMethod === 'mobile_money'
      }
    },
    {
      name: "accountNumber",
      type: "text",
      admin: {
        description: "Bank account number or mobile money number",
        condition: (data) => data.paymentMethod === 'bank_transfer' || data.paymentMethod === 'mobile_money'
      }
    },
    {
      name: "amount",
      type: "number",
      required: true,
      admin: {
        description: "Transaction amount in Rwandan Francs (RWF)"
      }
    },
    {
      name: "currency",
      type: "text",
      defaultValue: "RWF",
      admin: {
        readOnly: true,
        description: "Currency (Rwandan Francs)"
      }
    },
  ],
};
